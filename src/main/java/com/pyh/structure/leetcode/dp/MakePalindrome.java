package com.pyh.structure.leetcode.dp;

/**
 * 类MakePalindrome的实现描述：求解把一个字符串变成回文字符串所需要的插入字符串最少的次数
 *
 * @author panyinghua 2021-4-23 15:50
 */
public class MakePalindrome {

    public static void main(String[] args) {
        System.out.println(mp("abcea"));
        System.out.println(mp("aba"));
    }

    /**
     * 把字符串s变为回文字符串需要插入的最少字符数
     * @param s
     * @return
     */
    public static int mp(String s) {

        // dp[i][j]表示的是把字符串s[i...j]变成回文所需要的最小插入字符数
        // 现在考虑怎么从子问题的解推导出来父问题的解
        // 加入我们知道子问题 dp[i+1][j-1]的解，也就是把字符串s[i+1...j-1]变成回文需要插入的最小字符数
        // 那么dp[i][j]的值就在于如何处理s[i]  s[j]这两个字符上
        // s[i]  s[j]有如下两种可能
        // 1.s[i]=s[j]，那么此时不需要任何插入操作，因为s[i+1...j-1]变成回文需要插入的最小字符数为dp[i+1][j-1]，再加上两个相等的字符s[i]  s[j]，不需要任何操作，此时的字符串也是回文字符串
        // s[i]=s[j]的情况下，也就是 dp[i][j]=dp[i+1][j-1]
        // 2.s[i]!=s[j]，这个时候就很复杂，我们分析下
        // s[i]  s[j] 不相等的话，我们要把包含s[i]  s[j]的字符串变为回文字符串，
        // 想想是不是要在s[j]右边插入一个s[i]，在s[i]右边插入字符s[j]，需要两次插入操作，这样就是一个回文字符串 s[i]s[j]...s[i+1...j-1]...s[j][si]
        // （注意，往s[j]左边插入一个s[i]，在s[i]左边插入字符s[j]也是一样的）s[j]s[i]...s[i+1...j-1]...[si]s[j]
        // s[i]!=s[j]的情况下，这个做法就是 dp[i][j]=dp[i+1][j-1]+2 ，这个是不是正确的做法呢？正常情况下是，但是有一些特殊场景不是，看如下字符串
        // [c,b,a,a,a,a,a,a]
        //    i         j
        // 按照上边的做法，我们需要在i的右边插入字符a，在j的右边插入字符b，两个操作把s[i...j]变为回文，实际上最优解是只需要在j的右边插入一个字符s[i]就是字符b即可
        // [a,a,a,a,a,a,b,c]
        //    i         j
        // （注意，往s[j]左边插入一个s[i]，在s[i]左边插入字符s[j]也是一样的）
        // 我们不能无脑的插入两个字符来推导结果！！！
        // 可以这样思考，
        // 如果 s[i+1...j]本身已经是回文字符串的字符数，然后再往j右边插入字符s[i]，此时只需要再插入一次字符的操作就可以满足
        // 如果 s[i...j-1]本身已经是回文字符串的字符数，然后在往i左边插入字符s[j]，此时只需要再插入一次字符的操作就可以满足
        // 对于这两种怎么求解呢？我们求解的是最小插入次数，那么这两个结果只要取其中的较小值就可以了
        // s[i]!=s[j]的情况下，dp[i][j]=min(dp[i+1][j],dp[i][j-1])+1
        // 根据上述分析，得出了灵魂的dp式子
        // if s[i]=s[j]
        //     dp[i][j]=dp[i+1][j-1]
        // else
        //     dp[i][j]=min(dp[i+1][j],dp[i][j-1])+1
        //
        // 再看base case
        // dp[i][j]表示的是s[i...j]的回文编辑插入字符数最少，
        // 那如果i=j的情况下是不需要插入任何字符的，所以i=j的时候，dp[i][j]=0
        // 而且当i>j的那部分dp数组元素我们无需关注，也无需遍历
        // 此时我们遍历数组的时候只关注 dp数组里边的右上半部分即可
        //

        int n=s.length();
        int[][] dp = new int[n][n];
        /*for(int i=0;i<n;i++) {
            for(int j=0;j<n;j++) {
                dp[i][j]=0;
                if(i==j) {
                    dp[i][j]=0;
                }
            }
        }*/
        for(int i=0;i<n;i++) {
            dp[i][i]=0;
        }

        // 思考下遍历方式，类似思路参见LPS类里边求解一个字符串里边的最长回文子序列
        // dp[i][j]只跟 dp[i+1][j-1]  dp[i+1][j]  dp[i][j-1] 这三个相关，分别位于dp[i][j]的左下方、正下方、正前方
        // 也就是说在求解dp[i][j]的时候，我们需要先求解i+1行的值，需要先求解j-1列的值
        // 那么对于i这个维度来说需要从下到上遍历，对于j维度来说需要从左到右遍历
        //
        //
        //
        // dp[n-1][n-1]这个值已经初始化为0，无需处理
        // i从下往上，其实可以从n-2开始遍历，因为i=n-1的时候，j=i+1也就是等于n了，内层循环根本不用进入执行，所以不会出现i+1越界的情况
        for(int i=n-1;i>=0;i--) {
            for(int j=i+1;j<n;j++) {
                if(s.charAt(i)==s.charAt(j)) {
                    dp[i][j] = dp[i+1][j-1];
                } else {
                    dp[i][j] = Math.min(dp[i+1][j],dp[i][j-1])+1;
                }
            }
        }

        // dp[0][n-1]表示的是s[0...n-1]变为回文字符串需要插入的最少字符数，s[0...n-1]也就是整个字符串s本身了
        return dp[0][n-1];
    }
}
