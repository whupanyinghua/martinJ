package com.pyh.structure.leetcode.dp;

/**
 * 类LPS的实现描述：最长回文子序列
 * 求解一个字符串中的最长回文子序列的长度
 * @author panyinghua 2021-4-13 18:16
 */
public class LPS {

    public static int lps(String s) {

        // 一个字符串的最长xxx子序列问题，都可以考虑使用双指针在字符串中遍历，尝试下使用动态规划，定义dp数组，以及明确状态的转移
        // dp[i][j]表示的是 s[i...j]的最长回文子序列的长度，如何通过dp[i][j]的子问题dp[i+1][j-1]来求解dp[i][j]呢?
        // dp[i+1][j-1]表示的是 s[i+1...j-1]的最长回文子序列的长度s[i+1...j-1]是s[i...j]的子串
        // 如果知道子问题 dp[i+1][j-1]，如何求解 dp[i][j]？
        // 这个时候结果就由s[i] s[j]来决定了
        // 假如 s[i]==s[j],那么有 dp[i][j] = dp[i+1][j-1]+2
        // 假如 s[i]!=s[j],这个时候情况就复杂了，算法的核心关键点就在于这里的取值
        // 怎么求解dp[i][j]呢？
        // s[i]!=s[j]，s[i] s[j]两个不可能都在LPS中，最多只有一个在，或者两个都不在，下面罗列下这三种情况
        // dp[i][j-1] 可以表示  s[i] 在，s[j]不在，
        // dp[i+1][j] 可以表示  s[i] 不在，s[j]在，
        // s[i-1] s[j+1] 都不在的话，那么 dp[i][j]=dp[i+1][j-1]
        // s[i...j]最长回文子序列，在 s[i]!=s[j]的情况下，直接取这三个情况中的max就好了。
        // dp[i][j]=max(dp[i][j-1],dp[i+1][j],dp[i+1][j-1])
        // 这三个式子中可以明显得出 dp[i][j-1]>=dp[i+1][j-1],dp[i+1][j]>=dp[i+1][j-1]，所以max表达式可以优化下
        // dp[i][j]=max(dp[i][j-1],dp[i+1][j])
        // dp转移方程
        // if s[i]==s[j]
        //     dp[i][j] = dp[i+1][j-1]+2
        // else
        //     dp[i][j]=max(dp[i][j-1],dp[i+1][j])
        // 再根据dp的定义来定义base case
        // 因为定义dp[i][j]是字符s[i...j]的最长回文子串，那么隐藏的条件是i<=j，我们后续在遍历的时候，只需要遍历i<j的单元即可
        // 如果在i>j的dp数组中都初始化为0
        // 而且可以明显的看出在i=j的时候dp[i][j]=1(只有一个元素的情况回文子序列的长度肯定就是1啦)，就是斜对角线上所有的dp元素都是1
        // 再看for循环遍历的方式
        // dp[i][j]只跟 dp[i+1][j-1]、dp[i][j-1]、dp[i+1][j]相关，这几个位置分别为位于dp[i][j]的左下方、左边、正下方
        // 那么遍历方式可以才从下往上，从左往右的遍历方式，确保这三个表达式在dp[i][j]之前运算完成
        int n=s.length();
        int[][] dp = new int[n][n];

        // base case
        for(int i=0;i<n;i++) {
            for(int j=0;j<n;j++) {
                dp[i][j] = 0;
                if(i==j) {
                    dp[i][j] = 1;
                }
            }
        }

        // 那么遍历方式可以才从下往上，从左往右的遍历方式，确保这三个表达式在dp[i][j]之前运算完成
        // i从下往上，其实可以从n-2开始遍历，因为i=n-1的时候，j=i+1也就是等于n了，内层循环根本不用进入执行
        for(int i=n-1;i>=0;i--) {
            // j从左往右
            for(int j=i+1;j<n;j++) {
                if(s.charAt(i)==s.charAt(j)) {
                    dp[i][j] = dp[i+1][j-1]+2;
                } else {
                    dp[i][j] = Math.max(dp[i][j-1],dp[i+1][j]);
                }
            }
        }

        // dp[0][n-1]表示的是s[0...n-1]也就是整个字符串的最长回文子序列了
        return dp[0][n-1];
    }


    public static int lps2(String s) {

        // 从父问题推断子问题不经常用，因为要转成代码还需要再加工下，一般是从子问题推导出父问题，由小及大 参见lps方法

        // 一个字符串的最长xxx子序列问题，都可以考虑使用双指针在字符串中遍历，尝试下使用动态规划，定义dp数组，以及明确状态的转移
        // dp[i][j]表示的是 s[i...j]的最长回文子序列的长度，如何通过dp[i][j]来求解福问题dp[i-1][j+1]?
        // 如果知道 dp[i+1][j-1]，如何求解 dp[i][j]？   dp[i+1][j-1]表示的是 s[i+1...j-1]的最长回文子序列的长度
        // 假如 s[i-1]==s[j+1],那么有 dp[i-1][j+1] = dp[i][j]+2
        // 假如 s[i-1]!=s[j+1],这个时候情况就复杂了，算法的核心关键点就在于这里的取值
        // s[i-1]!=s[j+1]，s[i-1] s[j+1]两个不可能都在LPS中，最多只有一个在，或者两个都不在，下面罗列下这三种情况
        // dp[i-1][j] 可以表示  s[i-1] 在，s[j+1]不在，
        // dp[i][j+1] 可以表示  s[i-1] 不在，s[j+1]在，
        // s[i-1] s[j+1] 都不在的话，那么 dp[i-1][j+1]=dp[i][j]
        // 最长回文子序列，在 s[i-1]!=s[j+1]的情况下，直接取这三个情况中的max就好了。
        // dp[i-1][j+1]=max(dp[i-1][j],dp[i][j+1],dp[i][j])

        // 从父问题推断子问题不经常用，因为要转成代码还需要再加工下，一般是从子问题推导出父问题，由小及大

        return 0;
    }
}
